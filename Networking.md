# Live JSON Requests #

The following sections describe the packet format used to communicate between the parser and the client user interface during live scenarios.

Whenever the client makes a live request to the server, it provides a timestamp parameter called "ts". The timestamp parameter is used to track the last time that the client received an update from the server. When the page first loads, the timestamp parameter will be 0, which indicates that the client currently has no data and the server should send all information that encompasses the current state of the system. In subsequent sections, this operation is referred to as a "full sync". The server also includes a current timestamp in the results, which the client will then use as input for the next request. That allows the server to send "diffs" of only those packets generated since the last update time.

Any response from the server will be formatted as an array of logical packets. Therefore, it is legal for the server to return 0 or more packets in response to a single network request. The server may also choose to sleep the connection for up to a minute if no relevant changes have been processed. Each packet will use the following general format:

```
{ "type": "my_type", "data": { } }
```

The attribute "type" must be a unique string that is used to identify the type of the data being sent. The packet type is used by the client to direct the data to the appropriate widget in the page for display. The data attribute can be any valid JSON object such as an array, object, or string. Each packet type can have a different data format that is understood by some part of the client and the server. Specific packet types are described in the subsequent sections below.


---


## Game Packet ##
The game packet is used to signify the start of a new game or just as a description of the currently running game if the client joins in the middle of one. This packet must be included during a full sync.

### Parameters ###
  * map - The unique id of the map, which comes directly from the game logs.
  * type - The unique id of the game type, which comes directly from the game logs.
  * time - The maximum time of the game in seconds as an integer.

### Examples ###
```
{ "type": "game", "data": { "map": "mp_uo_carentan", "type": "tdm", "time": 1800 } }
```


---


## Event Packet ##
The event packet marks the occurrence of a significant event in the game, such as when a player captures an objective. All event packets for the current game must be included during a full sync. The event packet can also be used to simply track the current game time, which is accomplished by omitting the team parameter. Contrary to the game event packets, only the most recent game time packet needs to be sent during a full sync.

### Parameters ###
  * time - The game time of the event in seconds as an integer.
  * team - The first letter of the team that caused the event. Valid values: a, b, g, r.

### Examples ###
```
{ "type": "event", "data": { "time": 30, "team": "a" } }

{ "type": "event", "data": { "time": 500 } }
```


---


## Map Packet ##
The map packet describes a single kill in the game, which includes information about the killer, victim, and their locations. Only the last 25 packets should be included during a full sync to improve performance.

### Parameters ###
**TODO** - Associate these coordinates with specific players.
  * dx/dy - The x/y coordinates of the victim projected onto the 2D map as integers.
  * kx/ky - The x/y coordinates of the killer projected onto the 2D map as integers.

### Examples ###
```
{ "type": "map", "data": { "dx": 3500, "dy": 2700, "kx": 3600, "ky": 2800 } }
```


---


## Player Packet ##
The player packet describes changes to the active roster of players within the current game. It is used to describe a player joining, leaving, or changing status within the game. Players are tracked using an identifier that is generated by the server, which must remain unique and associated with the same player for the duration of a single game. Once a new player is added to the system, their id number can be used for subsequent operations such as when the player's name/statistics change or the player leaves the game. All active players and their associated parameters should be included during a full sync and after a new game is started. The id parameter is always required for all operations. The first time a player joins, all of the other parameters are required. During an update operation all the other parameters are optional, while remove operations only require the empty team parameter. Note that the player packet data may be delivered as a single object or an array of information in order to reduce overhead since it is highly likely that more than one player will change state at the same time.

### Parameters ###
  * id - The unique id of a player that changed state. Always required. May be a number or string.
  * name - The display name of the player.
  * photo - The url of the player's photo.
  * place - The player's overall standing based on kills for the current game.
  * rank - The player's experience standing in-game for the current game.
  * team - The symbol for the team of the player. Valid values: a (American), b (British), g (German), r (Russian), s (Spectator), "" (Player Left).
  * kills/deaths - The number of kills and deaths accumulated by the player.
  * inflicted/received - The amount of damage inflicted and received by the player.
  * trend - The trend of the player's kill ratio. Valid values: + (Increased), - (Decreased), "" (No Change)

### Examples ###
```
{ "type": "player", "data": [ { "id": 10, "name": "Player A" } ] }

{ "type": "player", "data": [ { "id": 10, "name": "Player A2" } ] }

{ "type": "player", "data": [ { "id": 10, "kills": 20 } ] }

{ "type": "player", "data": [ { "id": 10, "team": "" } ] }
```


---


## Timestamp Packet ##
The timestamp packet allows the server to stay synchronized with the client, by providing the time of the most recently processed update. This packet should be included in all server responses to maximize performance.

### Parameters ###
  * N/A - This packet just includes the current number of game records.

### Examples ###
```
{ "type": "ts", "data": 1258694307 }
```


---


# Index JSON Requests #
The following sections describe the packet format used to communicate between the parser and the client user interface for static page content.

Whenever the client loads a static content page, it may optionally make an index request from the server. An index request returns a listing of all the JSON files that are relevant to the current context. Player, map, game, and award pages are all associated with index listings. The first part of an index url indicates the type of data that should be listed, such as the example below:

`http://gday/stats/awards/index.json`

Each index response includes a list of entries, where each entry consists of a display name, id, and tool tip. All of this information is used to present the user with the available options and load the data selected by the user. An example snippet for the award page index is included below:

```
[
  { "name": "Award 1", "id": "award_1", "tip": "This is award 1" },
  { "name": "Award 2", "id": "award_2", "tip": "This is award 2" }
]
```

The id parameter above is particularly interesting because it provides additional flexibility. Each context will be associated with a particular path which will be configured on the server and in the UI pages. So for example all asynchronous requests for awards pages will be of the form:

`awards/award_1.json`

During the live event, this path could be intercepted dynamically by a servlet that generates the content on-demand. That way we can avoid actually writing a large number of data files to disk, most of which will never be requested by a user. This should also greatly improve parser performance between games. Furthermore, subsequent requests for the same index or its associated data files could be cached by the server for the duration of the current game to further reduce server load.

Then, when the site is hosted as static content after the event, all of the data could actually be written out as files on disk. That way the site and its data can be served without running any type of server-side code without requiring any code changes.

Also note in the snippet above, any special characters in the entry names that are invalid for URLs should be replaced in the id attribute. So if a player includes a space in their name, that should be changed to another character such as an underscore.

Another important detail is that the format of the content that is retrieved for an item, such as award results, can be different for each page context. For example, it is likely that the award files and player files will require completely different values in order to display the desired results to the user. However, the format of the _index_ files for each type of page, as specified above, will be the same in order to maximize code reuse.

Although the content for each page can be different, it will follow the same general structure. First, it will declare its table columns and then all of the table data as a 2-dimensional array. The values can be given using many different data types as specified in the column definition, including: numbers, strings, or JSON objects. If a custom JSON object is returned, such as a player, then a corresponding UI table renderer must be created in order to display it in a meaningful way. Unsupported object types will just be displayed as strings in the table. A default sort column and sort direction can be applied adding an optional attribute to a column. The sort attribute accepts a boolean to represent direction: true for ascending or false for descending. An example snippet for the award page content is included below:

```
{
  "columns": [
    { "name": "Name", "type": "string" },
    { "name": "Value", "type": "number", "sort": false }
  ],
  "rows": [
    [ "Luda", "10" ],
    [ "Clint", "20" ]
  ]
}
```

URL fragments will be used based on the item id in order to approximate a REST-style system. If a user wants to request a specific award, the url would like this:

`http://gday/stats/awards.html#award_1`

The awards.html UI will first request the index list using the url given earlier. Once the index is retrieved, it will use the id attribute as the fragment of the url. It will then try to request and display the content for that specific award if available. If the specified award does not exist, then an error message will be shown to the user. The URL fragment solution is nice because it is easy to read, supports proper bookmarking, and use of the browser's back button.