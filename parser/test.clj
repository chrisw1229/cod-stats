(use 'org.stoop.codParser 'org.stoop.codData 'org.stoop.codAnalytics     'org.stoop.parser     'clojure.contrib.json.write 'clojure.contrib.duck-streams 'clojure.contrib.seq-utils);Award related functions(defn write-award [file award-name award-data]  (spit file (json-str {:award award-name :data award-data})));Name resolution functions(defn is-alias? [player-one player-two]  (or (= (:name player-one) (:name player-two))      (= (:id player-one) (:id player-two))))(defn get-aliases [log-seq nested-keys player-object]  (get-unique-from-seq    (filter #(is-alias? player-object (get-in % nested-keys)) log-seq)   nested-keys))(defn get-nth-level-aliases [log-seq nested-keys player-object n]  (loop [accum-aliases []	 aliases [player-object]	 iteration n]    (if (< iteration 0)      accum-aliases      (recur (distinct (concat accum-aliases aliases))	     (filter #(not (includes? accum-aliases %)) (mapcat #(get-aliases log-seq nested-keys %) aliases))	     (dec iteration)))));File watching functions(defn tail-f [file delay action]  (let [keep-running (atom true)	current-line (StringBuilder.)	thread (Thread. #(try			  (with-open[fis (java.io.FileInputStream. file)				     bis (java.io.BufferedInputStream. fis)]			    (while @keep-running			      (let [input-char (.read bis)]				(cond 				  (= input-char -1) (Thread/sleep delay)				  				  (= (char input-char) \newline)				  (do				    (action (.toString current-line))				    (.setLength current-line 0))				  				  true (.append current-line (char input-char))))))			  (catch java.io.FileNotFoundException e			    (println "File " file " does not exist."))			  (catch SecurityException e			    (println "Security denies access to " file e))			  (catch java.io.IOException e			    (println "Error reading file " file e))			  (catch InterruptedException e			    (println "Thread interrupted while reading " file e))))]    {:start #(.start thread)     :stop #(do (reset! keep-running false)		(.join thread)		(println "tail-f has stopped."))}));Real time processing;Need some kind of storage for the records as they come in.;Possibly store based upon the type of record?;Might as well go with the cached method.  So as data comes in, add it to a data set to be processed.;During processing, compute the stats for the current "new" data set.;Update the old stats based upon the new;Store the just processed "new" data in the "old" data set.;When a new game starts, reset the current stats and archive out the "old" data set.(def new-records (ref '()))(def old-records (ref []))(defn process-input-line [input-line]  (let [parsed-input (parse input-line log-line)]    ;Filter so we only store records in new-records that need to be passed to the front-end    (dosync (ref-set new-records (conj @new-records parsed-input)))));process-parsed-input;if this is a damage-kill record  ;find-player attacker & victim    ;if name changed, update player name    ;if team changed, reset stats    ;if new-player, add new player to stats set    ;return player  ;update attacker inflicted and victim received  ;if this is a kill-record    ;update attacker kills and victim deaths    ;recalculate places    ;recalculate and update attacker rank;if this is a quit record  ;remove player from stats set?;Stats  ;Player    ;name    ;photo - where do i get this?    ;place    ;rank    ;team    ;kills    ;deaths    ;inflicted    ;received;on front-end update  ;turn stats-set into json and send out  ;json new-records and send out  ;move new-records to old-records;AJAX out new-records continuously?;Do I limit number of markers that appear on the map?